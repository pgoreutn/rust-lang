# Common Collections

Rust’s standard library includes a number of very useful data structures called collections. 
Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs.
We’ll discuss three collections that are used very often in Rust:
* vector allows you to store a variable number of values next to each other.
* string is a collection of characters.
* hash map allows you to associate a value with a particular key.

## Storing lists of values with vectors

Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. 

### Creating a New Vector

To create a new, empty vector, we can call the Vec::new function

```Rust
let v: Vec<i32> = Vec::new();
```

In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. 
Rust provides the vec! macro for convenience. The macro will create a new vector that holds the values you give it.
creates a new Vec<i32> that holds the values 1, 2, and 3.

```Rust
let v = vec![1, 2, 3];
```
Because we’ve given initial i32 values, Rust can infer that the type of v is Vec<i32>, and the type annotation isn’t necessary.

### Updating a Vector

To create a vector and then add elements to it, we can use the push method
```Rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

```
As with any variable, if we want to be able to change its value, we need to make it mutable
```

### Reading Elements of Vectors

There are two ways to reference a value stored in a vector.

```Rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
   Some(third) => println!("The third element is {}", third),
   None => println!("There is no third element."),
}
```

First, we use the index value of 2 to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using & and [], which gives us a reference, or by using the get method with the index passed as an argument, which gives us an Option<&T>.

```Rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

When we run this code, the first [] method will cause the program to panic because it references a nonexistent element. 
When the get method is passed an index that is outside the vector, it returns None without panicking.

```
    Recall the rule that states you can’t have mutable and immutable references in the same scope.
    Where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won't work.

```

```Rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {}", first);
```

```
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {}", first);
|                                             ----- immutable borrow later used here
```