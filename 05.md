# The Big Ideas – Ownership and Borrowing

Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector

## What is Ownership ?

Rust memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.

## The Stack & the Heap

The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as last in, first out.
Adding data is called pushing onto the stack, and removing data is called popping off the stack.
All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating. 


## Ownership Rules

* Each value in Rust has a variable that’s called its owner.
* There can be only one owner at a time.
* When the owner goes out of scope, the value will be dropped.

## Variable Scope

A scope is the range within a program for which an item is valid. Let’s say we have a variable that looks like this:

```Rust
let s = "hello";
```

The variable is valid from the point at which it’s declared until the end of the current scope .

```Rust
{                       // s is not valid here; it's not yet declared
    let s = "hello";    // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid

```

When a variable goes out of scope, Rust calls a special function for us. This function is called drop, and it’s where the author of String can put the code to return the memory. Rust calls drop automatically at the closing curly bracket.


## The String Type

We’ll use String as the example here and concentrate on the parts of String that relate to ownership .

**String** , this type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time.


## Ways That Variables and Data Interact: Move

```Rust
let x = 5;
let y = x;
```

We can probably guess what this is doing: “bind the value 5 to x; then make a copy of the value in x and bind it to y.” We now have two variables, x and y, and both equal 5. This is indeed what is happening, because integers are simple values with a known, fixed size and these two 5 values are pushed onto the stack.

Now let’s look at the String version:

```Rust
let s1 = String::from("hello");
let s2 = s1;
```

This looks very similar to the previous code , the second line would make a copy of the value in s1 and bind it to s2. But this isn’t quite what happens.

A String is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity. This group of data is stored on the stack. On the right is the memory on the heap that holds the contents.

 ![](/images/5-1.png)


When we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to.

![](/images/5-2.png)

Earlier, we said that when a variable goes out of scope, Rust automatically calls the drop function and cleans up the heap memory for that variable.
This is a problem: when s2 and s1 go out of scope, they will both try to free the same memory. This is known as a double free error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.

## Ownership and Functions

```Rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to
                                    // still use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved,
  // nothing special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.

```